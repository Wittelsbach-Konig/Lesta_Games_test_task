# Улучшенный алгоритм быстрой сортировки
Улучшенный алгоритм быстрой сортировки, который сочетает в себе несколько оптимизаций для повышения производительности и стабильности. Алгоритм использует оптимизацию хвостовой рекурсии (TCO), сортировку вставками для малых подмассивов, стратегию медианы трёх для выбора опорного элемента, разбиение Хоара.

## Особенности
- **Оптимизация хвостовой рекурсии (TCO):** Уменьшает глубину рекурсивных вызовов, заменяя их итеративными циклами. Сначала происходит рекурсивный вызов для меньшего подмассива.

Было:
```python
    if left < right:
        center_idx = lomuto_partion(array, left, right)
        quicksort_inplace(array, left, center_idx-1)
        quicksort_inplace(array, center_idx+1, right)
```
Стало:
```python
    while left < right:
        mid = hoare_partition(array, left, right)
        if mid - left < right - mid:
            optimized_quicksort(array[left:mid])
            left = mid + 1
        else:
            optimized_quicksort(array[mid+1:right])
            right = mid
```
- **Сортировка вставками:** Используется для малых подмассивов, чтобы улучшить производительность на почти отсортированных данных. Эмпирическим путём был подобран размер подмассива - MAX_ARRAY_SIZE = **16**.
```python
    while left < right:
        if right - left < MAX_ARRAY_SIZE:
            insertion_sort(array, left, right)
            break
        else:
            mid = hoare_partition(array, left, right)
            if mid - left < right - mid:
                optimized_quicksort(array[left:mid])
                left = mid + 1
            else:
                optimized_quicksort(array[mid+1:right])
                right = mid
```
- **Разбиение Хоара:** Более эффективный метод разбиения по сравнению с разбиением Ломуто, , так как требует меньше обменов и перемещений.
- **Стратегия медианы трёх:** Выбирает опорный элемент как медиану из первого, среднего и последнего элементов, чтобы избежать наихудшего сценария на уже отсортированных массивах.

## Сравнение с обычной быстрой сортировкой
Обычная быстрая сортировка имеет следующие характеристики:
- Временная сложность:
    - Средняя - O(n log n), каждое разбиение делит массив пополам.
    - Худшая - O(n^2), каждое разбиение делит массив на подмассив длиной 1 и подмассив длиной n-1 (отсортированный массив).
- Пространственная сложность:
    - Средняя - O(log n).
    - Худшая - O(n), когда массив уже отсортирован.

Улучшенная версия быстрой сортировки имеет следующие характеристики:
- Временная сложность:
    - Средняя - O(n log n)
    - Худшая - O(n log n) стратегия выбора опорного элемента с помощью медианы трёх позволяет избежать O(n^2).
- Пространственная сложность:
    - Средняя - O(log n).
    - Худшая - O(log n), использование оптимизации хвостовой рекурсии позволяет снизить использование дополнительной памяти.

Алгоритм улучшенной быстрой сортировки с медианой трёх и разбиением Хоара показывает более стабильную производительность по сравнению с классической быстрой сортировкой, особенно для уже отсортированных или частично отсортированных массивов. Это достигается за счёт улучшенной стратегии выбора опорного элемента и оптимизаций для малых подмассивов.
## График сравнения быстродействия сортировок
Тесты быстродействия производились на массивах разной длины от 10 до 10^6. Массивы были разделены на 3 группы: массив со случайными значениями, частично отсортированный, полностью от сортированный массив. Каждый тест запускался 20 раз, после чего считалась среднее время сортировки. Для наглядности был построен график времени сортировки от размера массива. Помимо улучшенной быстрой сортировки и обычной сортировки тестировались сортировка слиянием и пирамидальная сортировка.

![sorts_comparison](https://github.com/user-attachments/assets/ea88eec3-b160-4548-ad3f-977e25230548)

По результатам тестирования можно сделать вывод, что улучшенная быстрая сортировка показывает лучшую производительность относительно всех, особенно на частично отсортированных и полностью отсортированных массивах.
